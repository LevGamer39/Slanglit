# bot.py
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, Message, CallbackQuery
import sqlite3
from database import FDataBase
from typing import Tuple, Optional
from secret import BOT_TOKEN
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup


def connect_db():
    return sqlite3.connect('translations.db')
db = FDataBase(connect_db())
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

def translate_to_formal(text: str, user_id: int = None) -> Tuple[str, Optional[str]]:
    original_text = text
    result = db.get_formal_translation(text.lower())
    if result:
        formal_text, explanation = result
        explanation_text = f"{text} ‚Üí {formal_text}: {explanation}" if explanation else None
        db.add_translation(text, formal_text, explanation_text, user_id)
        return formal_text, explanation_text
    
    words = text.split()
    formal_parts = []
    explanations = []
    
    i = 0
    while i < len(words):
        found = False
        for length in range(min(3, len(words) - i), 0, -1):
            phrase = ' '.join(words[i:i + length])
            result = db.get_formal_translation(phrase.lower())
            if result:
                formal_phrase, explanation = result
                formal_parts.append(formal_phrase)
                if explanation:
                    explanations.append(f"{phrase} ‚Üí {formal_phrase}: {explanation}")
                i += length
                found = True
                break
        
        if not found:
            formal_parts.append(words[i])
            i += 1
    
    formal_text = ' '.join(formal_parts)
    explanation_text = '\n'.join(explanations) if explanations else None
    
    db.add_translation(text, formal_text, explanation_text, user_id)
    
    return formal_text, explanation_text

def translate_to_informal(text: str, user_id: int = None) -> Tuple[str, Optional[str]]:
    words = text.split()
    informal_parts = []
    explanations = []
    
    i = 0
    while i < len(words):
        found = False
        for length in range(min(3, len(words) - i), 0, -1):
            phrase = ' '.join(words[i:i + length])
            result = db.get_informal_translation(phrase.lower())
            if result:
                informal_phrase, explanation = result
                informal_parts.append(informal_phrase)
                if explanation:
                    explanations.append(f"{phrase} ‚Üí {informal_phrase}: {explanation}")
                i += length
                found = True
                break
        
        if not found:
            informal_parts.append(words[i])
            i += 1
    
    informal_text = ' '.join(informal_parts)
    explanation_text = '\n'.join(explanations) if explanations else None
    
    db.add_translation(text, informal_text, explanation_text, user_id)
    
    return informal_text, explanation_text


class TranslationStates(StatesGroup):
    waiting_for_informal = State()
    waiting_for_formal = State()

main_keyboard = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üìñ –ò—Å—Ç–æ—Ä–∏—è"), KeyboardButton(text="üìö –°–ª–æ–≤–∞—Ä—å")],
        [KeyboardButton(text="üîç –ü–æ–∏—Å–∫"), KeyboardButton(text="üîÑ –ü–µ—Ä–µ–≤–æ–¥")]
    ],
    resize_keyboard=True
)

translation_keyboard = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üé© –ù–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π ‚Üí –§–æ—Ä–º–∞–ª—å–Ω—ã–π")],
        [KeyboardButton(text="üòé –§–æ—Ä–º–∞–ª—å–Ω—ã–π ‚Üí –ù–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]
    ],
    resize_keyboard=True
)

translation_mode_keyboard = ReplyKeyboardMarkup(
    keyboard=[[KeyboardButton(text="‚ùå –í—ã–π—Ç–∏ –∏–∑ —Ä–µ–∂–∏–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞")]],
    resize_keyboard=True
)


@dp.message(Command("start"))
async def start_command(message: types.Message):
    await message.answer(
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –º–µ–∂–¥—É —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–º –∏ –Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–º —Å—Ç–∏–ª–µ–º.\n\n"
        "üìù –ò—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏!",
        reply_markup=main_keyboard
    )


@dp.message(TranslationStates.waiting_for_informal)
async def handle_informal_text(message: types.Message, state: FSMContext):
    if message.text == "‚ùå –í—ã–π—Ç–∏ –∏–∑ —Ä–µ–∂–∏–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞":
        await state.clear()
        await message.answer("‚úÖ –í—ã—à–µ–ª –∏–∑ —Ä–µ–∂–∏–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞", reply_markup=main_keyboard)
        return
    
    user_text = message.text
    formal_text, explanation = translate_to_formal(user_text, message.from_user.id)
    
    response = f"üé© –§–æ—Ä–º–∞–ª—å–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç:\n`{formal_text}`"
    if explanation:
        response += f"\n\nüìö –û–±—ä—è—Å–Ω–µ–Ω–∏–µ:\n{explanation}"
    
    await message.answer(response, parse_mode='Markdown', reply_markup=translation_mode_keyboard)

@dp.message(TranslationStates.waiting_for_formal)
async def handle_formal_text(message: types.Message, state: FSMContext):
    if message.text == "‚ùå –í—ã–π—Ç–∏ –∏–∑ —Ä–µ–∂–∏–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞":
        await state.clear()
        await message.answer("‚úÖ –í—ã—à–µ–ª –∏–∑ —Ä–µ–∂–∏–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞", reply_markup=main_keyboard)
        return
    
    user_text = message.text
    informal_text, explanation = translate_to_informal(user_text, message.from_user.id) 
    
    response = f"üòé –ù–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç:\n`{informal_text}`"
    if explanation:
        response += f"\n\nüìö –û–±—ä—è—Å–Ω–µ–Ω–∏–µ:\n{explanation}"
    
    await message.answer(response, parse_mode='Markdown', reply_markup=translation_mode_keyboard)


@dp.message(lambda message: message.text == "üé© –ù–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π ‚Üí –§–æ—Ä–º–∞–ª—å–Ω—ã–π")
async def start_formal_translation(message: types.Message, state: FSMContext):
    await state.set_state(TranslationStates.waiting_for_informal)
    await message.answer(
        "‚úÖ –†–µ–∂–∏–º: –ù–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π ‚Üí –§–æ—Ä–º–∞–ª—å–Ω—ã–π\n\n"
        "–û—Ç–ø—Ä–∞–≤—å –Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞:\n"
        "(–¥–ª—è –≤—ã—Ö–æ–¥–∞ –Ω–∞–∂–º–∏ ‚ùå –í—ã–π—Ç–∏ –∏–∑ —Ä–µ–∂–∏–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞)",
        reply_markup=translation_mode_keyboard
    )


@dp.message(lambda message: message.text == "üòé –§–æ—Ä–º–∞–ª—å–Ω—ã–π ‚Üí –ù–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π")
async def start_informal_translation(message: types.Message, state: FSMContext):
    await state.set_state(TranslationStates.waiting_for_formal)
    await message.answer(
        "‚úÖ –†–µ–∂–∏–º: –§–æ—Ä–º–∞–ª—å–Ω—ã–π ‚Üí –ù–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π\n\n"
        "–û—Ç–ø—Ä–∞–≤—å —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞:\n"
        "(–¥–ª—è –≤—ã—Ö–æ–¥–∞ –Ω–∞–∂–º–∏ ‚ùå –í—ã–π—Ç–∏ –∏–∑ —Ä–µ–∂–∏–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞)",
        reply_markup=translation_mode_keyboard
    )
    

@dp.message(lambda message: message.text == "‚ùå –í—ã–π—Ç–∏ –∏–∑ —Ä–µ–∂–∏–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞")
async def exit_translation_mode(message: types.Message, state: FSMContext):
    current_state = await state.get_state()
    if current_state is not None:
        await state.clear()
    await message.answer(
        "‚úÖ –í—ã—à–µ–ª –∏–∑ —Ä–µ–∂–∏–º–∞ –ø–µ—Ä–µ–≤–æ–¥–∞",
        reply_markup=main_keyboard
    )

@dp.message(lambda message: message.text == "üîÑ –ü–µ—Ä–µ–≤–æ–¥")
async def show_translation_options(message: types.Message):
    await message.answer(
        "üîÑ –í—ã–±–µ—Ä–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞:",
        reply_markup=translation_keyboard
    )

@dp.message(lambda message: message.text == "üìñ –ò—Å—Ç–æ—Ä–∏—è")
async def history_button(message: types.Message):
    await show_history(message)

@dp.message(lambda message: message.text == "üìö –°–ª–æ–≤–∞—Ä—å")
async def dictionary_button(message: types.Message):
    await show_dictionary(message)

@dp.message(lambda message: message.text == "üîç –ü–æ–∏—Å–∫")
async def search_button(message: types.Message):
    await message.answer("üîç –í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É: /search <—Ç–µ–∫—Å—Ç>")

@dp.message(lambda message: message.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def go_back_to_mode_selection(message: types.Message, state: FSMContext):
    current_state = await state.get_state()
    if current_state is not None:
        await state.clear()
    await message.answer(
        "üîÑ –í—ã–±–µ—Ä–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–≤–æ–¥–∞:",
        reply_markup=translation_keyboard
    )



@dp.message(Command("help"))
async def help_command(message: types.Message):
    await message.answer(
        "‚ÑπÔ∏è –ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º:\n\n"
        "1. üìù –ù–∞–ø–∏—à–∏ –ª—é–±–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä: '–ø—Ä–∏–≤–µ—Ç –±—Ä–æ')\n"
        "2. ü§ñ –ë–æ—Ç –æ—Ç–≤–µ—Ç–∏—Ç —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–º –≤–∞—Ä–∏–∞–Ω—Ç–æ–º\n"
        "3. üíæ –ü–µ—Ä–µ–≤–æ–¥ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ –±–∞–∑—É\n"
        "4. üìñ –°–º–æ—Ç—Ä–∏ –∏—Å—Ç–æ—Ä–∏—é –∫–æ–º–∞–Ω–¥–æ–π /history\n"
        "5. üìö –°–º–æ—Ç—Ä–∏ —Å–ª–æ–≤–∞—Ä—å –∫–æ–º–∞–Ω–¥–æ–π /dictionary\n"
        "6. üîç –ò—â–∏ –ø–µ—Ä–µ–≤–æ–¥—ã –∫–æ–º–∞–Ω–¥–æ–π /search\n\n"
        "–ü—Ä–∏–º–µ—Ä: /search –∫—Ä–∏–Ω–∂"
    )


@dp.message(Command("history"))
async def show_history(message: types.Message):
    translations = db.get_user_translations(message.from_user.id)
    
    if not translations:
        await message.answer("üì≠ –í–∞—à–∞ –∏—Å—Ç–æ—Ä–∏—è –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –ø—É—Å—Ç–∞")
        return
    
    page_translations = translations[:5]
    
    text = "üìñ –í–∞—à–∞ –∏—Å—Ç–æ—Ä–∏—è –ø–µ—Ä–µ–≤–æ–¥–æ–≤:\n\n"
    for i, trans in enumerate(page_translations, 1):
        text += f"{i}. üòé `{trans['informal_text']}`\n"
        text += f"   üé© `{trans['formal_text']}`\n"
        text += f"   üìÖ {trans['created_at']}\n\n"
    
    keyboard = []
    if len(translations) > 5:
        keyboard.append([InlineKeyboardButton(text="‚û°Ô∏è –ü–æ–∫–∞–∑–∞—Ç—å –µ—â–µ", callback_data=f"next_5_{message.from_user.id}")])  # –î–æ–±–∞–≤–ª–µ–Ω user_id –≤ callback
    keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="history_back")])
    
    reply_markup = InlineKeyboardMarkup(inline_keyboard=keyboard)
    
    await message.answer(text, reply_markup=reply_markup, parse_mode='Markdown')



@dp.message(Command("dictionary"))
async def show_dictionary(message: types.Message):
    words = db.get_dictionary()
    
    if not words:
        await message.answer("üì≠ –°–ª–æ–≤–∞—Ä—å –ø—É—Å—Ç")
        return
    
    text = "üìö –°–ª–æ–≤–∞—Ä—å —Å–ª–æ–≤:\n\n"
    for i, word in enumerate(words, 1):
        text += f"{i}. üòé `{word['informal_text']}` ‚Üí üé© `{word['formal_text']}`"
        if word.get('explanation'):
            text += f"\n   üìñ {word['explanation']}\n\n"
        else:
            text += "\n\n"
    
    await message.answer(text, parse_mode='Markdown')


@dp.message(Command("search"))
async def search_translations(message: types.Message):
    try:
        parts = message.text.split(' ', 1)
        if len(parts) < 2:
            await message.answer("‚ùå –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /search <—Ç–µ–∫—Å—Ç>\n–ù–∞–ø—Ä–∏–º–µ—Ä: /search –∫—Ä–∏–Ω–∂")
            return
            
        search_text = parts[1].strip()
        
        if not search_text:
            await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞")
            return
            
        results = db.search_user_translations(search_text, message.from_user.id)
        
        if not results:
            await message.answer(f"üîç –ü–æ –∑–∞–ø—Ä–æ—Å—É '{search_text}' –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –≤–∞—à–µ–π –∏—Å—Ç–æ—Ä–∏–∏")
            return
        
        text = f"üîç –ù–∞–π–¥–µ–Ω–æ {len(results)} –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –≤ –≤–∞—à–µ–π –∏—Å—Ç–æ—Ä–∏–∏:\n\n"
        for i, trans in enumerate(results, 1):
            text += f"{i}. üòé `{trans['informal_text']}`\n"
            text += f"   üé© `{trans['formal_text']}`\n"
            text += f"   üìÖ {trans['created_at']}\n\n"
        
        await message.answer(text, parse_mode='Markdown')
        
    except Exception as e:
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ")
        print(f"‚ùå –û—à–∏–±–∫–∞ –≤ /search: {e}")


@dp.message(Command("stats"))
async def show_stats(message: types.Message):
    user_stats = db.get_user_stats(message.from_user.id)
    global_stats = db.get_stats()
    
    text = (
        "üìä –í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n\n"
        f"‚Ä¢ üìñ –í–∞—à–∏—Ö –ø–µ—Ä–µ–≤–æ–¥–æ–≤: {user_stats.get('user_translations', 0)}\n"
        f"‚Ä¢ üî¢ –í–∞—à–∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π: {user_stats.get('user_usage', 0)}\n\n"
        "üìä –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–∞–∑—ã:\n"
        f"‚Ä¢ üìö –°–ª–æ–≤ –≤ —Å–ª–æ–≤–∞—Ä–µ: {global_stats.get('total_words', 0)}"
    )
    
    await message.answer(text)


@dp.message(Command("add_word"))
async def add_word_command(message: types.Message):
    try:
        text = message.text.strip()
        parts = text.split(' ', 1)
        
        if len(parts) < 2:
            await message.answer(
                '‚ùå –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /add_word –Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π [–æ–±—ä—è—Å–Ω–µ–Ω–∏–µ]\n\n'
                '–ü—Ä–∏–º–µ—Ä—ã:\n'
                '/add_word –∫—Ä–∏–Ω–∂ –Ω–µ–ª–æ–≤–∫–æ\n'
                '/add_word "–≥–æ –≤ –¥–æ—Ç—É" "–ø–æ—à–ª–∏ –≤ Dota 2" "–ü—Ä–∏–∑—ã–≤ –ø–æ–∏–≥—Ä–∞—Ç—å –≤ –∏–≥—Ä—É Dota 2"\n'
                '/add_word –±—Ä–æ —É–≤–∞–∂–∞–µ–º—ã–π –∫–æ–ª–ª–µ–≥–∞ –Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω–æ–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ –¥—Ä—É–≥—É'
            )
            return
        args_text = parts[1]
        
        import shlex
        try:
            args = shlex.split(args_text)
        except:
            args = args_text.split(' ', 2)
        
        if len(args) < 2:
            await message.answer(
                '‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ:\n'
                '/add_word "–Ω–µ—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π" "—Ñ–æ—Ä–º–∞–ª—å–Ω—ã–π" "–æ–±—ä—è—Å–Ω–µ–Ω–∏–µ"\n\n'
                '–ü—Ä–∏–º–µ—Ä:\n'
                '/add_word "–≥–æ –≤ –¥–æ—Ç—É" "–ø–æ—à–ª–∏ –≤ Dota 2" "–ü—Ä–∏–∑—ã–≤ –ø–æ–∏–≥—Ä–∞—Ç—å –≤ –∏–≥—Ä—É Dota 2"'
            )
            return
            
        informal = args[0]
        formal = args[1]
        explanation = args[2] if len(args) > 2 else ''
        
        if db.add_to_dictionary(informal, formal, explanation):
            response = f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ —Å–ª–æ–≤–∞—Ä—å:\nüòé `{informal}` ‚Üí üé© `{formal}`"
            if explanation:
                response += f"\nüìö {explanation}"
            await message.answer(response, parse_mode='Markdown')
        else:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å")
            
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")



@dp.callback_query(lambda c: c.data.startswith('next_'))
async def show_more(callback: CallbackQuery):
    try:
        parts = callback.data.split('_')
        offset = int(parts[1])
        user_id = int(parts[2]) if len(parts) > 2 else callback.from_user.id
        
        translations = db.get_user_translations(user_id, limit=1000)
        
        page_translations = translations[offset:offset+5]
        
        if not page_translations:
            await callback.answer("–ë–æ–ª—å—à–µ –ø–µ—Ä–µ–≤–æ–¥–æ–≤ –Ω–µ—Ç")
            return
        
        text = "üìñ –í–∞—à–∞ –∏—Å—Ç–æ—Ä–∏—è –ø–µ—Ä–µ–≤–æ–¥–æ–≤:\n\n"
        for i, trans in enumerate(page_translations, offset + 1):
            text += f"{i}. üòé `{trans['informal_text']}`\n"
            text += f"   üé© `{trans['formal_text']}`\n"
            text += f"   üìÖ {trans['created_at']}\n\n"
        
        keyboard_buttons = []
        if offset > 0:
            keyboard_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"next_{offset-5}_{user_id}"))
        if offset + 5 < len(translations):
            keyboard_buttons.append(InlineKeyboardButton(text="–í–ø–µ—Ä–µ–¥ ‚û°Ô∏è", callback_data=f"next_{offset+5}_{user_id}"))
        
        reply_markup = InlineKeyboardMarkup(inline_keyboard=[keyboard_buttons])
        
        await callback.message.edit_text(text, reply_markup=reply_markup, parse_mode='Markdown')
        await callback.answer()
    except Exception as e:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ")
        print(f"‚ùå –û—à–∏–±–∫–∞ –≤ show_more: {e}")


@dp.message()
async def handle_any_message(message: Message):
    if not message.text or message.text.startswith('/'):
        return
    
    try:
        user_text = message.text
        formal_text, explanation = translate_to_formal(user_text, message.from_user.id)
        
        response = f"üé© –§–æ—Ä–º–∞–ª—å–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç:\n`{formal_text}`"
        
        if explanation:
            response += f"\n\nüìö –û–±—ä—è—Å–Ω–µ–Ω–∏–µ:\n{explanation}"
        
        response += f"\n\nüíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –±–∞–∑—É!"
        
        await message.answer(response, parse_mode='Markdown')
    except Exception as e:
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è")
        print(f"‚ùå –û—à–∏–±–∫–∞ –≤ handle_any_message: {e}")


async def main():
    print("‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    print("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö: translations.db")
    print("üìù –ü—Ä–æ—Å—Ç–æ –ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏—è - –æ–Ω–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è—Ç—Å—è!")
    print("üëÄ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /history –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏—Å—Ç–æ—Ä–∏–∏")
    print("üìö –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /dictionary –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å–ª–æ–≤–∞—Ä—è")
    print("üîç –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /search –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–æ–≤")
    await dp.start_polling(bot)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())